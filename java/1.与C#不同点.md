# 与C#不同点

### 语法

> 1. 常量使用 **final**标记
> 2. for each语法:
>
> ```java
> var ints = new int[] {1,2,3,4,5};
> for(int i:ints){
>     System.Out.println(i);
> }
> ```
>
> 3. 数组排序:
>
> ```java
> import java.util.Arrays;
> 
> var ns = new int[] {2,3,16,3,6,8,56,1412};
> Arrays.sort(ns);
> System.Output.println(Array.toString(ns));
> ```
>
> 4. 方法命名使用驼峰命名法:  methodInJava(){}
> 5. 多维数组:
>
> ```java
> //二维数组
> int[][] ns = {
>                 {1,2,3},
>                 {4,5,6},
>                 {7,8,9}
>             };
> //三维数组
> int[][][] ns = {
>     {
>         {1,2,3},
>         {4,5,6},
>         {7,8,9}
>     },
>     {
>         {1,2},
>         {4,5}
>     },
>     {
>         {1,2},
>         {4,5,131}
>     }
> };
> ```
>
> 6. 没有C#的属性
> 7. 继承-**只能继承一个父类**
>
> ```java
> class Student extends Person{
>     super(params);//调用了父类Person的有参构造函数
> }
> 
> //super表示父类
> //final修饰符可以阻止继承
> //sealed修饰符可以封装类
> public sealed class Shape permits Rect,Circle,Triangle{
>     //在声明父类时,通过permits明确指出从父类Shape中可以继承自己的子类名称
>     //例,Shape只允许Rect,Circle,Triangle三个类继承自己
> }
> 
> public final class Rect extends Shape{
>     //可以继承
> }
> 
> public final class Test extends Shape{
>     //不能继承
> }
> ```
>
> 8. 覆写override
>
> ```java
> class Person{
>     public void run(){
>         System.out.println("Person runs");
>     }
>     
>     public final String name = "Lemon";//用final标记的类的实例字段在初始化后不能被修改,可以在构造函数里初始化final字段
>     
>     public final void walk(){//final标记的方法不可以覆写
>         
>     }
> }
> 
> class Student extends Person{
>     @override //加上@override可以让编译器帮助检查是否进行了正确的覆写
>     public void run(){
>         System.out.println("Student runs");
>     }
>     
>     public void fatherClassRun(){
>         super.run();//调用父类的Run()方法
>     }
> }
> 
> ```
>
> 9. 抽象类同C#
> 10. 接口-**没有普通字段**,**只有静态字段和抽象方法**,**使用implements关键字**继承接口, **可实现多个接口**
>
> ```java
> interface Person{
>     public static final int MALE=1;//因为interface的字段只能是 public static final,所以可简写为int MALE=1
>     void run();
>     String getName();
> }
> 
> interface School extends Person{ //interface继承interface
>     void Study();
> }
> 
> class Student implements Person{
>     @override
>     public void run(){
>         System.out.println("Student runs");
>     }
>     @override
>     public String getName(){
>         return "StudentName";
>     }
> }
> 
> 
> class Student implements Person,School{//继承了两个接口
>     //TODO
> }
> 
> ```
>
> 11. 接口中的default方法-当给接口新增了一个方法时, 所有子类需要实现这个方法, **default修饰符能让新方法变成非抽象方法, 这样不用所有子类都要实现这个方法**,只要在需要override的子类中override就好了
>
> ```java
> interface Person{
>     String getName();
>     default void run(){
>         System.Output.println("run");
>     }
> }
> ```
>
> 





